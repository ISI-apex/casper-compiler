set(CASPER_COMPILER_LIB cac)

# Create a Casper executable (application)
# Arguments: app_target SOURCES source_file... HALIDE_GENERATORS gen1 ...
#   SOURCES: source files for the metaprogram, including Halide generators
#   HALIDE_GENERATORS: names of Halide generators registered
#		       in the metaprogram
#   KB_SOURCES: a temporary mockup: sources for the executable that
#                     produces a binary that produces a knowledgebase file
#   NOTE_TIME_IDS: a temporary mockup: platform hardware description
function(casper_add_exec target meta_prog)
	cmake_parse_arguments(FARG
		""
		"KB_MODEL;KB_MODEL_CP;KB_CANDIDATES"
		"SOURCES;HALIDE_GENERATORS;KB_SOURCES;NODE_TYPE_IDS"
			${ARGN})

	find_package(Threads)

	# TODO: FindCasper.cmake (figure out if functions go into Find*.cmake),
	# then move these out of the function
	find_program(LLC llc REQUIRED DOC "LLVM IR compiler")
	include_directories(${CAC_INCLUDE_DIRS})

	add_executable(${meta_prog} ${FARG_SOURCES})
	target_link_libraries(${meta_prog} LINK_PUBLIC ${CASPER_COMPILER_LIB})
	foreach(gen ${FARG_HALIDE_GENERATORS})
		# TODO: CAC should generate a .cmake file with this var set
		#       per each application
		foreach(node_type_id ${FARG_NODE_TYPE_IDS})
			# nameing convention contract with
			# makeHalideArtifactName() in build.cpp
			set(halide_lib lib${gen}_v${node_type_id}.a)
			list(APPEND halide_libs ${halide_lib})
		endforeach()
	endforeach()

	list(APPEND halide_libs libhalide_runtime.a)

	foreach(halide_lib ${halide_libs})
		list(APPEND halide_libs_paths
			${CMAKE_CURRENT_BINARY_DIR}/${halide_lib})
	endforeach()

	# Eventually, the profiling binary will be produced by a run of the
	# meta program. Until then, mock up a profiling binary as a simple
	# executable compiled from a pre-written source file, and add
	# a fake dependency on the metaprogram.

	set(kb_prog ${target}.kbprog)
	add_executable(${kb_prog} ${FARG_KB_SOURCES})
	# Technically, we only need libknowbase.so, but keep simple for now
	target_link_libraries(${kb_prog} ${CASPER_COMPILER_LIB})
	add_dependencies(${kb_prog} ${meta_prog})

	# Artifacts for knowledge base
	# If not generated by a target, then full path to source dir
	set(kb_model ${CMAKE_CURRENT_SOURCE_DIR}/${FARG_KB_MODEL})
	set(kb_model_cp ${CMAKE_CURRENT_SOURCE_DIR}/${FARG_KB_MODEL_CP})
	set(kb_xml ${target}.kb.structure.xml)
	set(kb_candidates ${CMAKE_CURRENT_SOURCE_DIR}/${FARG_KB_CANDIDATES})

	add_custom_command(OUTPUT ${kb_xml}
	  COMMAND ${kb_prog} ${kb_model} ${kb_model_cp} ${target}.kb
	  DEPENDS ${kb_prog})

	# Run the meta-program
	add_custom_command(OUTPUT ${target}.ll ${halide_libs}
	  COMMAND ${meta_prog} ${kb_xml} ${kb_candidates} 2> ${target}.ll
	  DEPENDS ${meta_prog} ${kb_xml})

	# Compile the target harness
	add_custom_command(OUTPUT ${target}.o
	  COMMAND ${LLC} -filetype=obj -o ${target}.o ${target}.ll
	  DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/${target}.ll)

	# Link the binary
	add_executable(${target} ${CMAKE_CURRENT_BINARY_DIR}/${target}.o)
	target_link_libraries(${target} ${halide_libs_paths}
		casper_runtime
		Threads::Threads ${CMAKE_DL_LIBS})
	set_target_properties(${target} PROPERTIES LINKER_LANGUAGE CXX)
endfunction()

# Add to app kernels written in C or C++ with C ABI
# Arguments: app_target source_file...
function(casper_add_c_kern app)
	set(lib ${app}_kern_c)
	add_library(${lib} ${ARGN})
	target_link_libraries(${app} ${lib})
endfunction()
